## 什么是GitOps？

GitOps是一种持续交付的方式。它的核心思想是将应用系统的声明性基础架构和应用程序存放在Git版本库中。

将Git作为交付流水线的核心，每个开发人员都可以提交拉取请求（Pull Request）并使用Gi​​t来加速和简化Kubernetes的应用程序部署和运维任务。通过使用像Git这样的简单工具，开发人员可以更高效地将注意力集中在创建新功能而不是运维相关任务上（例如，应用系统安装、配置、迁移等）。

* GitOps：集群管理和应用分发的持续交付方式
* 使用 Git 作为信任源，保存声明式基础架构（declarative infrastructure）
  和应用程序
* 以 Git 作为交付过程（pipeline）的中心
* 开发者只需要通过 pull request 完成应用的部署和运维任务
* 优势：
   提高生产率、改进开发体验、一致性和标准化、安全

## GitOps的基本原则

以下是在云原生环境中GitOps的原则：

* 任何能够被描述的内容都必须存储在Git库中

通过使用Git作为存储声明性基础架构和应用程序代码的存储仓库，可以方便地监控集群，以及检查比较实际环境的状态与代码库上的状态是否一致。所以，**我们的目标是描述系统相关的所有内容：策略，代码，配置，甚至监控事件和版本控制等**，并且将这些内容全部存储在版本库中，在通过版本库中的内容构建系统的基础架构或者应用程序的时候，如果没有成功，则可以迅速的回滚，并且重新来过。

* 不应直接使用Kubectl

作为一般规则，不提倡在命令行中直接使用kubectl命令操作执行部署基础架构或应用程序到集群中。还有一些开发者使用CI工具驱动应用程序的部署，但如果这样做，可能会给生产环境带来潜在不可预测的风险。

* 调用Kubernetes 的API的接口或者控制器应该遵循 Operator 模式

调用Kubernetes 的API的接口或者控制器应该遵循 Operator 模式（[什么是Operator 模式？](https://link.zhihu.com/?target=https%3A//coreos.com/blog/introducing-operators.html)），集群的状态和Git库中的配置文件等要保持一致，并且查看分析它们之间的状态差异。

## 最佳实践---以Git作为事实的唯一真实来源

Git是每个开发人员工具包的一部分。学习起来感觉自然而且不那么令人生畏，而且工具本身也非常简单。 通过使用Git作为应用系统的事实来源，几乎可以操作所有东西。例如，版本控制，历史记录，评审和回滚都是通过Git进行的，而无需使用像kubectl这样的工具。

所以，Git是GitOps形成的最基础的内容，就像第一条原则“任何能够被描述的内容都必须存储在Git库中 ”描述的那样：通过使用Git作为存储声明性基础架构和应用程序代码的存储仓库，可以方便地监控集群，以及检查比较实际环境的状态与代码库上的状态是否一致。所以，**我们的目标是描述系统相关的所有内容：策略，代码，配置，甚至监控事件和版本控制等**，并且将这些内容全部存储在版本库中，在通过版本库中的内容构建系统的基础架构或者应用程序的时候，如果没有成功，则可以迅速的回滚，并且重新来过。

## 拉式流水线——Pull Request操作

## 推送流水线

目前大多数CI / CD工具都使用基于推送的模型。基于推送的流水线意味着代码从CI系统开始，通过一系列构建测试等最终生成镜像，最后手动使用“kubectl”将任何更改推送到Kubernetes集群。

很多开发人员不愿意在CI中启动CD部署流程，或者使用命令行工具操作启动CD部署流程的原因可能是这样做会将集群的用户和密码等公布出去。虽然可以有措施保护CI / CD 脚本和命令行，但是这些操作毕竟还是在集群外部非可信区工作的。所以，类似做法是不可取的，会给系统安全带来潜在的风险。

具有集群外读/写（R/W）权限的典型推送流水线：![](/image/Istio/push-pipeline.png)

* CI运行测试，输出传递到容器映像存储库。

* CD系统自动部署容器（或根据请求，即手动）。

## 拉式流水线

在GitOps中，镜像被拉出并且凭证保留在集群中![](/image/Istio/pull-pipeline.png)

